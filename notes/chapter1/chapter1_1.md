# Notes in Chapter1
===================

## 1.1


### 概述

一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，是我们能够在其中组织自己有关计算机过程的思考。每一种强有力的语言都应该为此提供以下三种机制：

+ **基本表达形式** 用于表示语言所关心的最简单的个体。
+ **组合的方式** 通过它们可以从较简单的东西出发构造出复合的元素。
+ **抽象的方法** 通过它们可以为复合对象命名，并将它们当作单元去操作。

> 其实这恰恰表示物体（其实我更喜欢用‘object’来代替这个‘物体’，因为在英语里面‘object’的概念比在中文里面的‘物体’要广泛）的发展。基本表达形式所对应的是物体的元素，对于元素的组合使得物体横向发展，而对元素进行抽象使得物体纵向发展。


### 命名与环境

一般而言，计算得到的对象完全可以具有非常复杂的结构，如果每次需要使用它们时，都必须记住并重复地写出它们的细节，那将是极端不方便的事情。实际上，构造一个复杂的程序，也就是为了去一步步地创造出越来越复杂的计算性对象。解释器使这种逐步的程序构造变得非常方便，因为我们可以通过一系列的交互式动作，逐步创建起所需要的**名字-对象**关联。这种特征鼓励人们采用递增的方式去开发和调试程序。


### 组合式求值

组合式求值只有两个简单的步骤：

1. 求值该组合式的各个子表达式。
2. 将作为最左子表达式（运算符）的值的那个过程应用于相应的实际参数，所谓实际参数也就是其它子表达式（运算对象）的值。


### 过程

过程的一般定义如下：

    (define (<name> <formal parameters>) <body>)

对于过程的求值分两种形式，分别是**正则序求值**以及**应用序求值**，简单来说，正则序求值是__完全展开后归约__，而应用序求值则是__先求值参数然后应用__。

> 这两者的关系令我回想起编译原理里面学到的‘左递归’以及‘左递归的消除’。正则序求值对应的是如下文法模型：
>    A -> Aa | b
此文法在A能够展开的情况下都会对A进行展开，一直到A不能展开为止，才使用b进行代入。当然，这个递归的过程是可以无限进行下去的。而对于应用序求值，我想就对应于左递归的消除了：
>    A  -> bA'
>    A' -> aA' | e
其中的‘e’代表‘epsilon’，即空，在这种文法下面，只要能进行归约代换，就先把表达式进行归约和代换，而不会出现无穷递归的情况。


### 条件表达式与谓词

条件表达式的一般定义如下：

    (cond (<p1> <e1>)
          (<p2> <e2>)
          :
          :
          (<pn> <en>))

`cond`条件表达式由一系列的‘谓词-表达式’对组成，其工作过程是逐条判断谓词的正确性，如果谓词为真，就立刻跳出`cond`表达式，如果谓词为假，则继续判断下面一条‘谓词-表达式’对的正确性。如果无法找到正确的‘谓词-表达式’对，那么`cond`的值就没有定义。**在scheme中，真值为`#t`，假值为`#f`**。

另外一些条件表达形式：

    (if <predicate> <consequent> <alternative>)
    (and <e1> <e2> ... <en>)
    (or  <e1> <e2> ... <en>)
    (not <e>)


### 过程抽象

一个过程可以被抽象为一个可供操作的基本单元，当过程作如此抽象的时候，调用者就没有必要知道过程内部的实现方式，为此，过程就成了一个黑箱子。

当过程被抽象之后，其内部的变量也就没有必要被外部调用者所用，这些变量可以说是仅被这个过程所**约束**的。这些变量只有在该过程内部**活跃**，而这些变量活跃的作用域被称为**词法作用域**。
